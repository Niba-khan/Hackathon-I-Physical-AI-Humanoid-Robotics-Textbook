"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[51],{8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var i=s(6540);const t={},r=i.createContext(t);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}},9240:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var i=s(4848),t=s(8453);const r={},o="Chapter 2: Hands-on with Nodes, Publishers, Subscribers, Services, Message Flow",l={id:"content/modules/ros2-fundamentals/chapter-2",title:"Chapter 2: Hands-on with Nodes, Publishers, Subscribers, Services, Message Flow",description:"Objectives",source:"@site/docs/content/modules/001-ros2-fundamentals/chapter-2.md",sourceDirName:"content/modules/001-ros2-fundamentals",slug:"/content/modules/ros2-fundamentals/chapter-2",permalink:"/hackathon-textbook/docs/content/modules/ros2-fundamentals/chapter-2",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/content/modules/001-ros2-fundamentals/chapter-2.md",tags:[],version:"current",frontMatter:{},sidebar:"textbookSidebar",previous:{title:"Chapter 1: What ROS 2 Is and Why Middleware Matters for Humanoid Robots",permalink:"/hackathon-textbook/docs/content/modules/ros2-fundamentals/chapter-1"},next:{title:"Chapter 3: Python Agents \u2192 ROS 2 Control with rclpy + Intro to URDF",permalink:"/hackathon-textbook/docs/content/modules/ros2-fundamentals/chapter-3"}},a={},c=[{value:"Objectives",id:"objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Creating a Simple Publisher Node",id:"creating-a-simple-publisher-node",level:2},{value:"Creating a Simple Subscriber Node",id:"creating-a-simple-subscriber-node",level:2},{value:"Creating a Service Server",id:"creating-a-service-server",level:2},{value:"Creating a Service Client",id:"creating-a-service-client",level:2},{value:"Setting up the Package",id:"setting-up-the-package",level:2},{value:"Testing the Complete System",id:"testing-the-complete-system",level:2},{value:"Understanding Message Flow",id:"understanding-message-flow",level:2},{value:"Quality of Service (QoS) Considerations",id:"quality-of-service-qos-considerations",level:2},{value:"Hands-on Exercise 2.1: Implement Your Own Communication System",id:"hands-on-exercise-21-implement-your-own-communication-system",level:2},{value:"Validation Checklist",id:"validation-checklist",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"chapter-2-hands-on-with-nodes-publishers-subscribers-services-message-flow",children:"Chapter 2: Hands-on with Nodes, Publishers, Subscribers, Services, Message Flow"}),"\n",(0,i.jsx)(n.h2,{id:"objectives",children:"Objectives"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Create and run ROS 2 nodes with publishers and subscribers"}),"\n",(0,i.jsx)(n.li,{children:"Implement a service server and client"}),"\n",(0,i.jsx)(n.li,{children:"Understand message flow in ROS 2"}),"\n",(0,i.jsx)(n.li,{children:"Build a complete communication system with 2 nodes, 1 publisher, 1 subscriber, and 1 service"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.p,{children:"In this chapter, we'll move from theory to practice by implementing the core communication patterns in ROS 2. We'll create working examples that demonstrate how nodes communicate with each other through topics (publishers/subscribers) and services."}),"\n",(0,i.jsx)(n.h2,{id:"creating-a-simple-publisher-node",children:"Creating a Simple Publisher Node"}),"\n",(0,i.jsxs)(n.p,{children:["Let's create a node that publishes joint state information (simulating data from a humanoid robot's sensors). We'll use Python with the ",(0,i.jsx)(n.code,{children:"rclpy"})," client library."]}),"\n",(0,i.jsx)(n.p,{children:"First, create a package for our examples:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd ~/humanoid_ws/src\nros2 pkg create --build-type ament_python joint_publisher\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now, let's implement the publisher node. Create a file ",(0,i.jsx)(n.code,{children:"joint_publisher/joint_publisher/joint_publisher_node.py"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Header\n\nclass JointPublisher(Node):\n    def __init__(self):\n        super().__init__('joint_publisher')\n        self.publisher_ = self.create_publisher(JointState, 'joint_states', 10)\n        timer_period = 0.1  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n\n    def timer_callback(self):\n        msg = JointState()\n        msg.header = Header()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = \"base_link\"\n        \n        # Define joint names for a simple humanoid (e.g., hip, knee, ankle)\n        msg.name = ['left_hip_joint', 'left_knee_joint', 'left_ankle_joint', \n                   'right_hip_joint', 'right_knee_joint', 'right_ankle_joint']\n        \n        # Simulate changing joint positions (in radians)\n        msg.position = [0.1 * self.i, 0.05 * self.i, 0.02 * self.i,\n                       -0.1 * self.i, -0.05 * self.i, -0.02 * self.i]\n        \n        # Simulate velocities and efforts\n        msg.velocity = [0.01] * 6  # 6 joints\n        msg.effort = [0.5] * 6     # 6 joints\n        \n        self.publisher_.publish(msg)\n        self.get_logger().info(f'Publishing joint states: {msg.position}')\n        self.i += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    joint_publisher = JointPublisher()\n    rclpy.spin(joint_publisher)\n    joint_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"creating-a-simple-subscriber-node",children:"Creating a Simple Subscriber Node"}),"\n",(0,i.jsxs)(n.p,{children:["Now let's create a subscriber node that receives the joint states and processes them. Create a file ",(0,i.jsx)(n.code,{children:"joint_publisher/joint_publisher/joint_subscriber_node.py"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\n\nclass JointSubscriber(Node):\n    def __init__(self):\n        super().__init__('joint_subscriber')\n        self.subscription = self.create_subscription(\n            JointState,\n            'joint_states',\n            self.listener_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info(\n            f'Received joint states - Positions: {msg.position}, '\n            f'Velocities: {msg.velocity}, Efforts: {msg.effort}'\n        )\n\ndef main(args=None):\n    rclpy.init(args=args)\n    joint_subscriber = JointSubscriber()\n    rclpy.spin(joint_subscriber)\n    joint_subscriber.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"creating-a-service-server",children:"Creating a Service Server"}),"\n",(0,i.jsxs)(n.p,{children:["Now let's implement a service that allows other nodes to request specific gait patterns for our humanoid robot. Create ",(0,i.jsx)(n.code,{children:"joint_publisher/joint_publisher/gait_service.py"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_srvs.srv import Trigger\n\nclass GaitService(Node):\n    def __init__(self):\n        super().__init__('gait_service')\n        self.srv = self.create_service(Trigger, 'set_gait_pattern', self.set_gait_callback)\n\n    def set_gait_callback(self, request, response):\n        # In a real robot, this would set the gait pattern\n        # For this example, we'll just return success\n        self.get_logger().info('Setting gait pattern requested')\n        response.success = True\n        response.message = 'Gait pattern set successfully'\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    gait_service = GaitService()\n    rclpy.spin(gait_service)\n    gait_service.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"creating-a-service-client",children:"Creating a Service Client"}),"\n",(0,i.jsxs)(n.p,{children:["Now, let's create a client that can call our gait service. Create ",(0,i.jsx)(n.code,{children:"joint_publisher/joint_publisher/gait_client.py"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_srvs.srv import Trigger\n\nclass GaitClient(Node):\n    def __init__(self):\n        super().__init__('gait_client')\n        self.cli = self.create_client(Trigger, 'set_gait_pattern')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n        self.req = Trigger.Request()\n\n    def send_request(self):\n        self.future = self.cli.call_async(self.req)\n        rclpy.spin_until_future_complete(self, self.future)\n        return self.future.result()\n\ndef main(args=None):\n    rclpy.init(args=args)\n    gait_client = GaitClient()\n    response = gait_client.send_request()\n    if response is not None:\n        gait_client.get_logger().info(f'Result: {response.success}, {response.message}')\n    else:\n        gait_client.get_logger().info('Service call failed')\n\n    gait_client.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"setting-up-the-package",children:"Setting up the Package"}),"\n",(0,i.jsxs)(n.p,{children:["To make our nodes executable, we need to update the ",(0,i.jsx)(n.code,{children:"setup.py"})," file in the ",(0,i.jsx)(n.code,{children:"joint_publisher"})," directory:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from setuptools import setup\n\npackage_name = 'joint_publisher'\n\nsetup(\n    name=package_name,\n    version='0.0.0',\n    packages=[package_name],\n    data_files=[\n        ('share/ament_index/resource_index/packages',\n            ['resource/' + package_name]),\n        ('share/' + package_name, ['package.xml']),\n    ],\n    install_requires=['setuptools'],\n    zip_safe=True,\n    maintainer='your_name',\n    maintainer_email='your_email@example.com',\n    description='Simple joint publisher example for humanoid robot',\n    license='Apache License 2.0',\n    tests_require=['pytest'],\n    entry_points={\n        'console_scripts': [\n            'joint_publisher = joint_publisher.joint_publisher_node:main',\n            'joint_subscriber = joint_publisher.joint_subscriber_node:main',\n            'gait_service = joint_publisher.gait_service:main',\n            'gait_client = joint_publisher.gait_client:main',\n        ],\n    },\n)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"testing-the-complete-system",children:"Testing the Complete System"}),"\n",(0,i.jsx)(n.p,{children:"To test our communication system, we'll run the nodes in separate terminals:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Build the package:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd ~/humanoid_ws\ncolcon build --packages-select joint_publisher\nsource install/setup.bash\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"In Terminal 1, run the publisher:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 run joint_publisher joint_publisher\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsx)(n.li,{children:"In Terminal 2, run the subscriber:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 run joint_publisher joint_subscriber\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"4",children:["\n",(0,i.jsx)(n.li,{children:"In Terminal 3, run the service:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 run joint_publisher gait_service\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"5",children:["\n",(0,i.jsx)(n.li,{children:"In Terminal 4, run the client to test the service:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 run joint_publisher gait_client\n"})}),"\n",(0,i.jsx)(n.p,{children:"You should see the publisher sending messages, the subscriber receiving them, and the service responding to client requests."}),"\n",(0,i.jsx)(n.h2,{id:"understanding-message-flow",children:"Understanding Message Flow"}),"\n",(0,i.jsx)(n.p,{children:"The message flow in our system works as follows:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"joint_publisher"})," node publishes ",(0,i.jsx)(n.code,{children:"JointState"})," messages to the ",(0,i.jsx)(n.code,{children:"joint_states"})," topic every 0.1 seconds"]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"joint_subscriber"})," node subscribes to the ",(0,i.jsx)(n.code,{children:"joint_states"})," topic and processes incoming messages"]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"gait_service"})," node listens for service requests on the ",(0,i.jsx)(n.code,{children:"set_gait_pattern"})," service"]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"gait_client"})," node sends requests to the ",(0,i.jsx)(n.code,{children:"set_gait_pattern"})," service and receives responses"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This demonstrates the fundamental communication patterns in ROS 2:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Topics"})," for asynchronous one-to-many communication (publisher-subscriber)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Services"})," for synchronous request-response communication"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"quality-of-service-qos-considerations",children:"Quality of Service (QoS) Considerations"}),"\n",(0,i.jsx)(n.p,{children:"For humanoid robots, the timing of messages is critical for safety and performance. ROS 2 provides Quality of Service (QoS) profiles to handle different communication requirements:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSHistoryPolicy\n\n# For critical control messages, use reliable delivery\nqos_profile = QoSProfile(\n    reliability=QoSReliabilityPolicy.RELIABLE,\n    history=QoSHistoryPolicy.KEEP_LAST,\n    depth=10\n)\n\n# For sensor data that can tolerate some loss, use best effort\nsensor_qos = QoSProfile(\n    reliability=QoSReliabilityPolicy.BEST_EFFORT,\n    history=QoSHistoryPolicy.KEEP_LAST,\n    depth=5\n)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"hands-on-exercise-21-implement-your-own-communication-system",children:"Hands-on Exercise 2.1: Implement Your Own Communication System"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Create a new package called ",(0,i.jsx)(n.code,{children:"humanoid_controller"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd ~/humanoid_ws/src\nros2 pkg create --build-type ament_python humanoid_controller\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Implement a node that publishes head camera images (use the ",(0,i.jsx)(n.code,{children:"sensor_msgs/Image"})," message type)"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Create a subscriber that processes these images and publishes detected objects"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Implement an action server for head movement (use the ",(0,i.jsx)(n.code,{children:"control_msgs/FollowJointTrajectory"})," action)"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Test that all nodes can communicate properly"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"validation-checklist",children:"Validation Checklist"}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","I have created a publisher node that sends joint state messages"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","I have created a subscriber node that receives joint state messages"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","I have implemented a service server and client"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","I understand the difference between topics and services"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","I have tested the complete communication system with 2 nodes (publisher + subscriber) and 1 service"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","I understand Quality of Service concepts and their importance for humanoid robots"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"This chapter provided hands-on experience with creating and running ROS 2 nodes with different communication patterns. We implemented a publisher-subscriber pair for continuous data flow and a service-server/client pair for request-response interactions. We also explored Quality of Service considerations that are critical for humanoid robot applications."}),"\n",(0,i.jsx)(n.p,{children:"In the next chapter, we'll explore how to connect Python agents to ROS 2 using rclpy and introduce URDF for robot modeling."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);