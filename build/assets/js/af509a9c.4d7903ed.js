"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[943],{8177:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var a=i(4848),t=i(8453);const o={},s="Chapter 2: Gazebo Simulation Fundamentals - Physics Engine Basics, Environment Setup, Sensor Integration",r={id:"content/modules/digital-twin/chapter-2",title:"Chapter 2: Gazebo Simulation Fundamentals - Physics Engine Basics, Environment Setup, Sensor Integration",description:"Objectives",source:"@site/docs/content/modules/002-digital-twin/chapter-2.md",sourceDirName:"content/modules/002-digital-twin",slug:"/content/modules/digital-twin/chapter-2",permalink:"/hackathon-textbook/docs/content/modules/digital-twin/chapter-2",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/content/modules/002-digital-twin/chapter-2.md",tags:[],version:"current",frontMatter:{},sidebar:"textbookSidebar",previous:{title:"Chapter 1: Digital Twin Concepts - Purpose, Value, and Role in Humanoid Robotics",permalink:"/hackathon-textbook/docs/content/modules/digital-twin/chapter-1"},next:{title:"Chapter 3: Unity High-Fidelity Rendering & Interaction - Realistic Rendering, Human-Robot Interaction Scenes, Gazebo-Unity Bridging",permalink:"/hackathon-textbook/docs/content/modules/digital-twin/chapter-3"}},l={},c=[{value:"Objectives",id:"objectives",level:2},{value:"Introduction to Gazebo",id:"introduction-to-gazebo",level:2},{value:"Understanding Gazebo&#39;s Physics Engine",id:"understanding-gazebos-physics-engine",level:2},{value:"ODE (Open Dynamics Engine)",id:"ode-open-dynamics-engine",level:3},{value:"Bullet Physics",id:"bullet-physics",level:3},{value:"Simbody",id:"simbody",level:3},{value:"Setting Up a Basic Gazebo Environment",id:"setting-up-a-basic-gazebo-environment",level:2},{value:"1. Gazebo Installation and Setup",id:"1-gazebo-installation-and-setup",level:3},{value:"2. Creating Your First World File",id:"2-creating-your-first-world-file",level:3},{value:"3. Running Your World",id:"3-running-your-world",level:3},{value:"Physics Engine Configuration for Humanoid Robots",id:"physics-engine-configuration-for-humanoid-robots",level:2},{value:"Gravity Settings",id:"gravity-settings",level:3},{value:"Time Step Configuration",id:"time-step-configuration",level:3},{value:"Solver Parameters",id:"solver-parameters",level:3},{value:"Sensor Integration in Gazebo",id:"sensor-integration-in-gazebo",level:2},{value:"1. IMU (Inertial Measurement Unit)",id:"1-imu-inertial-measurement-unit",level:3},{value:"2. Depth Camera",id:"2-depth-camera",level:3},{value:"3. LiDAR Sensor",id:"3-lidar-sensor",level:3},{value:"Creating a Humanoid Robot Model with Sensors",id:"creating-a-humanoid-robot-model-with-sensors",level:2},{value:"Loading Your Robot in Gazebo",id:"loading-your-robot-in-gazebo",level:2},{value:"Physics Parameters Optimization for Humanoid Simulation",id:"physics-parameters-optimization-for-humanoid-simulation",level:2},{value:"Stability Considerations",id:"stability-considerations",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Hands-on Exercise 2.1: Create Your Own Simulation Environment",id:"hands-on-exercise-21-create-your-own-simulation-environment",level:2},{value:"Validation Checklist",id:"validation-checklist",level:2},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h1,{id:"chapter-2-gazebo-simulation-fundamentals---physics-engine-basics-environment-setup-sensor-integration",children:"Chapter 2: Gazebo Simulation Fundamentals - Physics Engine Basics, Environment Setup, Sensor Integration"}),"\n",(0,a.jsx)(e.h2,{id:"objectives",children:"Objectives"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Understand Gazebo's physics engine and its capabilities"}),"\n",(0,a.jsx)(e.li,{children:"Set up a basic simulation environment for humanoid robots"}),"\n",(0,a.jsx)(e.li,{children:"Integrate various sensors (LiDAR, Depth, IMU) into the simulation"}),"\n",(0,a.jsx)(e.li,{children:"Create and configure simulation worlds with realistic physics"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"introduction-to-gazebo",children:"Introduction to Gazebo"}),"\n",(0,a.jsx)(e.p,{children:"Gazebo is a 3D simulation environment that enables the accurate and efficient testing of robotics algorithms, designs, and scenarios. For humanoid robotics, Gazebo provides:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Realistic Physics"}),": Accurate simulation of forces, collisions, and dynamics"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Sensor Simulation"}),": Implementation of cameras, LiDAR, IMU, GPS, and other sensors"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Visual Rendering"}),": High-quality 3D rendering for visualization"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Plugin Architecture"}),": Extensible framework for custom sensors, actuators, and controllers"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"Gazebo integrates seamlessly with ROS/ROS 2, making it an ideal platform for testing humanoid robot algorithms before deployment on physical robots."}),"\n",(0,a.jsx)(e.h2,{id:"understanding-gazebos-physics-engine",children:"Understanding Gazebo's Physics Engine"}),"\n",(0,a.jsx)(e.p,{children:"Gazebo uses the Open-Source Physics Engine (OSPE) as its foundation, with support for multiple physics engines:"}),"\n",(0,a.jsx)(e.h3,{id:"ode-open-dynamics-engine",children:"ODE (Open Dynamics Engine)"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Most commonly used physics engine in Gazebo"}),"\n",(0,a.jsx)(e.li,{children:"Good balance between accuracy and performance"}),"\n",(0,a.jsx)(e.li,{children:"Well-suited for humanoid robots with articulated joints"}),"\n",(0,a.jsx)(e.li,{children:"Handles collisions, friction, and dynamics effectively"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"bullet-physics",children:"Bullet Physics"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"More advanced collision detection"}),"\n",(0,a.jsx)(e.li,{children:"Better for complex contact scenarios"}),"\n",(0,a.jsx)(e.li,{children:"More computationally intensive than ODE"}),"\n",(0,a.jsx)(e.li,{children:"Useful for precise manipulation tasks"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"simbody",children:"Simbody"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Multibody dynamics engine"}),"\n",(0,a.jsx)(e.li,{children:"Handles complex articulated systems well"}),"\n",(0,a.jsx)(e.li,{children:"More accurate for systems with many constraints"}),"\n",(0,a.jsx)(e.li,{children:"Less commonly used in robotics applications"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"setting-up-a-basic-gazebo-environment",children:"Setting Up a Basic Gazebo Environment"}),"\n",(0,a.jsx)(e.h3,{id:"1-gazebo-installation-and-setup",children:"1. Gazebo Installation and Setup"}),"\n",(0,a.jsx)(e.p,{children:"First, ensure you have Gazebo installed along with the necessary ROS interfaces:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"# For ROS 2 Humble with Gazebo Garden\nsudo apt-get install ros-humble-gazebo-ros-pkgs\nsudo apt-get install gazebo\n"})}),"\n",(0,a.jsx)(e.h3,{id:"2-creating-your-first-world-file",children:"2. Creating Your First World File"}),"\n",(0,a.jsxs)(e.p,{children:["World files in Gazebo are written in SDF (Simulation Description Format) and define the environment, physics parameters, and initial robot placement. Create ",(0,a.jsx)(e.code,{children:"my_humanoid_world.sdf"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="humanoid_world">\n    \x3c!-- Physics parameters --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000.0</real_time_update_rate>\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n\n    \x3c!-- Include common models --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Add a simple floor --\x3e\n    <model name="floor">\n      <pose>0 0 0 0 0 0</pose>\n      <link name="floor_link">\n        <collision name="floor_collision">\n          <geometry>\n            <box>\n              <size>10 10 0.1</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="floor_visual">\n          <geometry>\n            <box>\n              <size>10 10 0.1</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.7 0.7 0.7 1</ambient>\n            <diffuse>0.7 0.7 0.7 1</diffuse>\n            <specular>0.7 0.7 0.7 1</specular>\n          </material>\n        </visual>\n        <pose>0 0 -0.05 0 0 0</pose>\n      </link>\n    </model>\n\n    \x3c!-- Add a simple obstacle --\x3e\n    <model name="obstacle">\n      <pose>2 0 0 0 0 0</pose>\n      <link name="obstacle_link">\n        <collision name="obstacle_collision">\n          <geometry>\n            <box>\n              <size>0.5 0.5 1.0</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="obstacle_visual">\n          <geometry>\n            <box>\n              <size>0.5 0.5 1.0</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.8 0.3 0.3 1</ambient>\n            <diffuse>0.8 0.3 0.3 1</diffuse>\n            <specular>0.8 0.3 0.3 1</specular>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Light source --\x3e\n    <light name="sun_light" type="directional">\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <attenuation>\n        <range>1000</range>\n        <constant>0.9</constant>\n        <linear>0.01</linear>\n        <quadratic>0.001</quadratic>\n      </attenuation>\n      <direction>-0.5 -0.1 -0.9</direction>\n    </light>\n  </world>\n</sdf>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"3-running-your-world",children:"3. Running Your World"}),"\n",(0,a.jsx)(e.p,{children:"To run your world file:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"gz sim -r my_humanoid_world.sdf\n"})}),"\n",(0,a.jsx)(e.h2,{id:"physics-engine-configuration-for-humanoid-robots",children:"Physics Engine Configuration for Humanoid Robots"}),"\n",(0,a.jsx)(e.p,{children:"Humanoid robots have specific requirements for physics simulation:"}),"\n",(0,a.jsx)(e.h3,{id:"gravity-settings",children:"Gravity Settings"}),"\n",(0,a.jsx)(e.p,{children:"For Earth-based simulation:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:"<gravity>0 0 -9.8</gravity>\n"})}),"\n",(0,a.jsx)(e.h3,{id:"time-step-configuration",children:"Time Step Configuration"}),"\n",(0,a.jsx)(e.p,{children:"Humanoid robots require precise physics simulation:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:"<max_step_size>0.001</max_step_size> \x3c!-- 1ms time steps for accuracy --\x3e\n<real_time_factor>1.0</real_time_factor> \x3c!-- Run at real-time speed --\x3e\n<real_time_update_rate>1000.0</real_time_update_rate> \x3c!-- 1000 Hz update rate --\x3e\n"})}),"\n",(0,a.jsx)(e.h3,{id:"solver-parameters",children:"Solver Parameters"}),"\n",(0,a.jsx)(e.p,{children:"For humanoid robots with multiple joints:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:"<ode>\n  <solver>\n    <type>quick</type>\n    <iters>1000</iters> \x3c!-- More iterations for stability --\x3e\n    <sor>1.3</sor>\n  </solver>\n  <constraints>\n    <cfm>0.000001</cfm> \x3c!-- Constraint Force Mixing --\x3e\n    <erp>0.2</erp> \x3c!-- Error Reduction Parameter --\x3e\n    <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n    <contact_surface_layer>0.001</contact_surface_layer>\n  </constraints>\n</ode>\n"})}),"\n",(0,a.jsx)(e.h2,{id:"sensor-integration-in-gazebo",children:"Sensor Integration in Gazebo"}),"\n",(0,a.jsx)(e.h3,{id:"1-imu-inertial-measurement-unit",children:"1. IMU (Inertial Measurement Unit)"}),"\n",(0,a.jsx)(e.p,{children:"Add an IMU sensor to a robot model by including it in the URDF or SDF:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<sensor name="imu_sensor" type="imu">\n  <always_on>1</always_on>\n  <update_rate>100</update_rate>\n  <visualize>false</visualize>\n  <topic>imu/data</topic>\n  <imu>\n    <angular_velocity>\n      <x>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>2e-4</stddev>\n        </ne>\n      </x>\n      <y>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>2e-4</stddev>\n        </noise>\n      </y>\n      <z>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>2e-4</stddev>\n        </noise>\n      </z>\n    </angular_velocity>\n    <linear_acceleration>\n      <x>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>1.7e-2</stddev>\n        </noise>\n      </x>\n      <y>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>1.7e-2</stddev>\n        </noise>\n      </y>\n      <z>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>1.7e-2</stddev>\n        </noise>\n      </z>\n    </linear_acceleration>\n  </imu>\n</sensor>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"2-depth-camera",children:"2. Depth Camera"}),"\n",(0,a.jsx)(e.p,{children:"A depth camera is crucial for humanoid robots for navigation and obstacle detection:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<sensor name="depth_camera" type="depth">\n  <always_on>true</always_on>\n  <update_rate>30</update_rate>\n  <camera name="head">\n    <horizontal_fov>1.047</horizontal_fov>\n    <image>\n      <width>640</width>\n      <height>480</height>\n    </image>\n    <clip>\n      <near>0.1</near>\n      <far>10.0</far>\n    </clip>\n  </camera>\n  <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n    <frame_name>camera_frame</frame_name>\n    <topic_name>depth_camera/image_raw</topic_name>\n    <point_cloud_topic_name>depth_camera/points</point_cloud_topic_name>\n  </plugin>\n</sensor>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"3-lidar-sensor",children:"3. LiDAR Sensor"}),"\n",(0,a.jsx)(e.p,{children:"LiDAR is essential for mapping and navigation:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<sensor name="lidar" type="ray">\n  <pose>0.1 0 0.1 0 0 0</pose>\n  <ray>\n    <scan>\n      <horizontal>\n        <samples>720</samples>\n        <resolution>1</resolution>\n        <min_angle>-3.14159</min_angle>\n        <max_angle>3.14159</max_angle>\n      </horizontal>\n    </scan>\n    <range>\n      <min>0.1</min>\n      <max>30.0</max>\n      <resolution>0.01</resolution>\n    </range>\n  </ray>\n  <plugin name="lidar_controller" filename="libgazebo_ros_laser.so">\n    <topic_name>scan</topic_name>\n    <frame_name>lidar_frame</frame_name>\n  </plugin>\n</sensor>\n'})}),"\n",(0,a.jsx)(e.h2,{id:"creating-a-humanoid-robot-model-with-sensors",children:"Creating a Humanoid Robot Model with Sensors"}),"\n",(0,a.jsxs)(e.p,{children:["Let's create a simple humanoid robot model with integrated sensors. Create ",(0,a.jsx)(e.code,{children:"simple_humanoid_with_sensors.urdf"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_humanoid">\n  \x3c!-- Base/Body of the robot --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.3 0.2 0.5"/>\n      </geometry>\n      <material name="light_grey">\n        <color rgba="0.7 0.7 0.7 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.3 0.2 0.5"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="10.0"/>\n      <inertia ixx="1.0" ixy="0" ixz="0" iyy="1.0" iyz="0" izz="1.0"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Head with sensors --\x3e\n  <joint name="neck_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="head_link"/>\n    <origin xyz="0 0 0.35" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-0.785" upper="0.785" effort="10" velocity="1"/>\n  </joint>\n\n  <link name="head_link">\n    <visual>\n      <geometry>\n        <sphere radius="0.1"/>\n      </geometry>\n      <material name="white">\n        <color rgba="1 1 1 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <sphere radius="0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="2.0"/>\n      <inertia ixx="0.04" ixy="0" ixz="0" iyy="0.04" iyz="0" izz="0.04"/>\n    </inertial>\n  </link>\n\n  \x3c!-- IMU in the head --\x3e\n  <gazebo reference="head_link">\n    <sensor name="imu_sensor" type="imu">\n      <always_on>true</always_on>\n      <update_rate>100</update_rate>\n      <visualize>false</visualize>\n    </sensor>\n  </gazebo>\n\n  \x3c!-- Depth Camera in the head --\x3e\n  <gazebo reference="head_link">\n    <sensor name="depth_camera" type="depth">\n      <always_on>true</always_on>\n      <update_rate>30</update_rate>\n      <camera name="head_camera">\n        <horizontal_fov>1.047</horizontal_fov>\n        <image>\n          <width>640</width>\n          <height>480</height>\n        </image>\n        <clip>\n          <near>0.1</near>\n          <far>10.0</far>\n        </clip>\n      </camera>\n    </sensor>\n  </gazebo>\n\n  \x3c!-- Left Leg --\x3e\n  <joint name="left_hip_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="left_upper_leg"/>\n    <origin xyz="-0.1 0 -0.25" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-1.57" upper="1.57" effort="50" velocity="1"/>\n  </joint>\n\n  <link name="left_upper_leg">\n    <visual>\n      <geometry>\n        <cylinder length="0.4" radius="0.06"/>\n      </geometry>\n      <material name="red">\n        <color rgba="1 0 0 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="0.4" radius="0.06"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="3.0"/>\n      <inertia ixx="0.04" ixy="0" ixz="0" iyy="0.04" iyz="0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  <joint name="left_knee_joint" type="revolute">\n    <parent link="left_upper_leg"/>\n    <child link="left_lower_leg"/>\n    <origin xyz="0 0 -0.4" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="0" upper="2.35" effort="50" velocity="1"/>\n  </joint>\n\n  <link name="left_lower_leg">\n    <visual>\n      <geometry>\n        <cylinder length="0.4" radius="0.05"/>\n      </geometry>\n      <material name="red">\n        <color rgba="1 0 0 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="0.4" radius="0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="2.5"/>\n      <inertia ixx="0.03" ixy="0" ixz="0" iyy="0.03" iyz="0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Right Leg --\x3e\n  <joint name="right_hip_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="right_upper_leg"/>\n    <origin xyz="0.1 0 -0.25" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-1.57" upper="1.57" effort="50" velocity="1"/>\n  </joint>\n\n  <link name="right_upper_leg">\n    <visual>\n      <geometry>\n        <cylinder length="0.4" radius="0.06"/>\n      </geometry>\n      <material name="red">\n        <color rgba="1 0 0 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="0.4" radius="0.06"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="3.0"/>\n      <inertia ixx="0.04" ixy="0" ixz="0" iyy="0.04" iyz="0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  <joint name="right_knee_joint" type="revolute">\n    <parent link="right_upper_leg"/>\n    <child link="right_lower_leg"/>\n    <origin xyz="0 0 -0.4" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="0" upper="2.35" effort="50" velocity="1"/>\n  </joint>\n\n  <link name="right_lower_leg">\n    <visual>\n      <geometry>\n        <cylinder length="0.4" radius="0.05"/>\n      </geometry>\n      <material name="red">\n        <color rgba="1 0 0 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="0.4" radius="0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="2.5"/>\n      <inertia ixx="0.03" ixy="0" ixz="0" iyy="0.03" iyz="0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- LiDAR on top of the body --\x3e\n  <gazebo reference="base_link">\n    <sensor name="lidar" type="ray">\n      <pose>0.0 0.0 0.3 0 0 0</pose>\n      <ray>\n        <scan>\n          <horizontal>\n            <samples>720</samples>\n            <resolution>1</resolution>\n            <min_angle>-3.14159</min_angle>\n            <max_angle>3.14159</max_angle>\n          </horizontal>\n        </scan>\n        <range>\n          <min>0.1</min>\n          <max>30.0</max>\n          <resolution>0.01</resolution>\n        </range>\n      </ray>\n    </sensor>\n  </gazebo>\n</robot>\n'})}),"\n",(0,a.jsx)(e.h2,{id:"loading-your-robot-in-gazebo",children:"Loading Your Robot in Gazebo"}),"\n",(0,a.jsx)(e.p,{children:"To load your robot model in Gazebo, you'll need to create a launch file or use ROS2 to spawn the robot. Here's a simple Python script that launches Gazebo and spawns your robot:"}),"\n",(0,a.jsx)(e.p,{children:"Create a package for your simulation:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"cd ~/humanoid_ws/src\nros2 pkg create --build-type ament_python simulation_examples\n"})}),"\n",(0,a.jsxs)(e.p,{children:["Create a launch file ",(0,a.jsx)(e.code,{children:"simulation_examples/launch/spawn_humanoid.launch.py"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\n\ndef generate_launch_description():\n    # Path to the Gazebo launch file\n    gazebo_launch = PathJoinSubstitution([\n        FindPackageShare('gazebo_ros'),\n        'launch',\n        'gazebo.launch.py'\n    ])\n\n    # Include Gazebo launch\n    gazebo_launch_cmd = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(gazebo_launch),\n        launch_arguments={'world': 'path_to_your_world.sdf'}.items()\n    )\n\n    # Robot state publisher node\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        name='robot_state_publisher',\n        parameters=[{\n            'robot_description': open('path_to_your_robot.urdf', 'r').read()\n        }]\n    )\n\n    # Spawn entity node\n    spawn_entity = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=[\n            '-topic', 'robot_description',\n            '-entity', 'simple_humanoid'\n        ],\n        output='screen'\n    )\n\n    return LaunchDescription([\n        gazebo_launch_cmd,\n        robot_state_publisher,\n        spawn_entity\n    ])\n"})}),"\n",(0,a.jsx)(e.h2,{id:"physics-parameters-optimization-for-humanoid-simulation",children:"Physics Parameters Optimization for Humanoid Simulation"}),"\n",(0,a.jsx)(e.p,{children:"For humanoid robots, specific physics parameters need optimization:"}),"\n",(0,a.jsx)(e.h3,{id:"stability-considerations",children:"Stability Considerations"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Time Step"}),": Use smaller time steps (1ms) for better accuracy with many joints"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"ERP and CFM"}),": Adjust constraint parameters to balance stability and accuracy"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Constraint Iterations"}),": Increase iterations for models with many joints to improve stability"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Collision Detection"}),": Use simplified collision meshes where possible"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Update Rates"}),": Balance sensor update rates with computational performance"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Solver Types"}),": Choose appropriate solver based on simulation needs"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"hands-on-exercise-21-create-your-own-simulation-environment",children:"Hands-on Exercise 2.1: Create Your Own Simulation Environment"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"Create a new world file with a more complex environment containing:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Multiple obstacles with different shapes and sizes"}),"\n",(0,a.jsx)(e.li,{children:"Different surface materials (grass, concrete, etc.)"}),"\n",(0,a.jsx)(e.li,{children:"At least 3 different lighting conditions"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"Create a humanoid robot model with the following sensors:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"IMU in the torso"}),"\n",(0,a.jsx)(e.li,{children:"Depth camera in the head"}),"\n",(0,a.jsx)(e.li,{children:"LiDAR on the torso"}),"\n",(0,a.jsx)(e.li,{children:"Force-torque sensors in the feet"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"Set up the physics parameters optimized for humanoid robot simulation"}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"Launch your simulation and verify that all sensors are publishing data to ROS topics"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"validation-checklist",children:"Validation Checklist"}),"\n",(0,a.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","I understand Gazebo's physics engine and its capabilities"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","I can create and configure a basic simulation environment"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","I have successfully integrated multiple sensor types (IMU, Depth, LiDAR) into my simulation"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","I know how to optimize physics parameters for humanoid robot simulation"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","I have created a complete humanoid robot model with integrated sensors"]}),"\n",(0,a.jsxs)(e.li,{className:"task-list-item",children:[(0,a.jsx)(e.input,{type:"checkbox",disabled:!0})," ","I have tested that my simulation environment works properly with appropriate physics"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(e.p,{children:"This chapter provided a comprehensive overview of Gazebo simulation fundamentals with a focus on humanoid robotics. We covered the physics engine capabilities, environment setup procedures, and how to integrate key sensors (LiDAR, Depth, IMU) into the simulation. We also created a complete humanoid robot model with sensors and discussed optimization techniques for physics simulation."}),"\n",(0,a.jsx)(e.p,{children:"In the next chapter, we'll explore Unity for high-fidelity visualization and the integration between Gazebo and Unity for a complete digital twin solution."})]})}function m(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>r});var a=i(6540);const t={},o=a.createContext(t);function s(n){const e=a.useContext(o);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:s(n.components),a.createElement(o.Provider,{value:e},n.children)}}}]);